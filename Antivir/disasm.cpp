#include <string>
#include <fstream>
#include "disasm.h"

std::vector<std::string> opcodes_names = { "mov" };
std::vector<std::string> reg_names = {
	"ah", "al", "ax", "eax", "rax",
	"ch", "cl", "cx", "ecx", "rcx",
	"dh", "dl", "dx", "edx", "rdx",
	"bh", "bl", "bx", "ebx", "rbx",
	"--", "--", "sp", "esp", "rsp",
	"--", "--", "bp", "ebp", "rbp",
	"--", "--", "si", "esi", "rsi",
	"--", "--", "di", "edi", "rdi",
	"es", "cs", "ss", "ds", "fs", "gs"
};

std::vector<std::string> reg8_names = {
	"al", "cl", "dl", "bl", "ah", "ch", "dh", "bh"
};

void disasm_init() {
}

void init_transitions()
{

}

std::string parse_ops(int op_size, int addr_size, std::ifstream &fl)
{
	std::string res = "";

	return res;
}

bool is_string(char c)
{
	return (c == ' ' || c == '\n' || c == '\t' || c == '\b' || (c >= 'a'&&c <= 'z') || (c >= 'A'&&c <= 'Z'));

}
std::vector<std::string> bytes_names_by_op_size = { "-", "b", "w", "d" };
std::vector<int> addr_overrides = { 32, 16, 32 };
std::vector<int> addr_overrides_1 = { 32, 16, 64 };
int log2c(int a)
{
	int cnt = 0;
	while (a > 1)
	{
		cnt++;
		a /= 2;
	}
	return cnt;
}
std::string get_string(char x)
{
	// string class has a constructor 
	// that allows us to specify size of 
	// string as first parameter and character 
	// to be filled in given size as second 
	// parameter. 
	if (x == '\n')
		return "\\n";
	if (x == '\b')
		return "\\b";
	if (x == '\t')
		return "\\t";
	std::string s(1, x);

	return s;
}
std::vector<std::string> bytes_names(65);
std::string disasm_code(std::string filename, int mode)
{
	bytes_names[8] = "byte";
	bytes_names[16] = "word";
	bytes_names[32] = "dword";
	bytes_names[64] = "qword";
	std::string result = "; That code was generated by MrLolthe1st disassembler v0.0.1\n";
	std::ifstream fl(filename, std::ios::binary);
	if (!fl.is_open()) {

		return "1";
	}
	unsigned char * buffer = (unsigned char*)malloc(8);
	int seg_reg = 3, op_size = 1 << (mode + 4);
	unsigned char last_byte = 0; std::string rep_pr = "";
	while (1) {
		last_byte = *buffer; int lb = 0;
		unsigned long long a = 0;
		fl.read((char*)buffer, 1);

		if (fl.eof())
			break;
		switch (*buffer)
		{
		case 0x26: // ES Override
			seg_reg = 0;
			result += ";ES Override\n";
			continue;
		case 0x2E: // CS Override
			seg_reg = 1;
			result += ";CS Override\n";
			continue;
		case 0x36: // SS Override
			seg_reg = 2;
			result += ";SS Override\n";
			continue;
		case 0x3E: // DS Override
			seg_reg = 3;
			result += ";DS Override\n";
			continue;
		case 0x48:
			op_size = 64;
			result += ";Address size override 64\n";
			continue;
		case 0x60:
			if (op_size == 32)
				result += "pushad\n";
			else
				result += "pusha\n";
			break;
		case 0x61:
			if (op_size == 32)
				result += "popad\n";
			else
				result += "popa\n";

			break;
		case 0x64: // FS Override
			seg_reg = 4;
			result += ";FS Override\n";
			break;
		case 0x65: // GS Override
			seg_reg = 5;
			result += ";GS Override\n";
			break;
		case 0x66:
			op_size = addr_overrides[mode];
			result += ";Address size override\n";
			continue;
		case 0x90:
			result += "nop\n";
			break;
		case 0x98:
			if (op_size == 16)
				result += "cbw\n";
			else if (op_size == 32) result += "cwde\n";
			else if (op_size == 64) result += "cdqe\n";
			break;
		case 0x99:
			if (op_size == 16)
				result += "cwd\n";
			else if (op_size == 32) result += "cdq\n";
			else if (op_size == 64) result += "cqo\n";
			break;
		case 0x9B:
			result += "wait\n";
			break;
		case 0x9C:
			result += "pushf\n";
			break;
		case 0x9D:
			result += "popf\n";
			break;

		case 0xA4:
			result += "movsb\n";
			break;
		case 0xA5:
			result += rep_pr + "movs" + bytes_names_by_op_size[log2c(op_size) - 2] + "\n";
			rep_pr = "";
			break;
		case 0xA6:
			result += rep_pr + "cmpsb\n";
			rep_pr = "";
			break;
		case 0xA7:
			result += rep_pr + "cmps" + bytes_names_by_op_size[log2c(op_size) - 2] + "\n";
			rep_pr = "";
			break;
		case 0xAA:
			result += rep_pr + "stosb\n";
			rep_pr = "";
			break;
		case 0xAB:
			result += rep_pr + "stos" + bytes_names_by_op_size[log2c(op_size) - 2] + "\n";
			rep_pr = "";
			break;
		case 0xAC:
			result += rep_pr + "lodsb\n";
			rep_pr = "";
			break;
		case 0xAD:
			result += "lods" + bytes_names_by_op_size[log2c(op_size) - 2] + "\n";
			rep_pr = "";
			break;
		case 0xC2:
			result += "retn\n";
			break;
		case 0xC3:
			result += "ret\n";
			break;
		case 0xCB:
			result += "retf\n";
			break;
		case 0xCD:
			fl.read((char*)buffer, 1);
			result += "int " + std::to_string(*buffer) + "\n";
			break;
		case 0xCF:
			if (op_size == 64)
				result += "iretq\n";
			else if (op_size == 32)
				result += "iretd\n";
			else if (op_size == 16)
				result += "iretb\n";
			break;
		case 0xE8:
			fl.read((char*)buffer, mode * 2 + 2);
			result += "call ";
			if (*(int*)buffer >= 0) result += "+";
			result += std::to_string(*(int*)buffer) + "\n";
			break;
		case 0xE9:
			fl.read((char*)buffer, mode * 2 + 2);
			result += "jmp far ";
			if (*(int*)buffer >= 0) result += "+";
			result += std::to_string(*(int*)buffer) + "\n";
			break;
		case 0xEB:
			fl.read((char*)buffer, 1);
			result += "jmp near ";
			if (*(char*)buffer >= 0) result += "+";
			result += std::to_string(*(char*)buffer) + "\n";
			break;
		case 0xF8:
			result += "clc\n";

			break;
		case 0xF9:
			result += "stc\n";
			break;
		case 0xF2:
			rep_pr = "repnz ";
			continue;
		case 0xF3:
			rep_pr = "repz ";
			continue;
		case 0xFA:
			result += "cli\n";
			break;
		case 0xFB:
			result += "sti\n";
			break;
		case 0xFC:
			result += "cld\n";
			break;
		case 0xFD:
			result += "std\n";
			break;
		default:
			if (op_size != (1 << (mode + 4)) && rep_pr == "")
				result += "db " + std::to_string(last_byte) + "\n";
			if (is_string(*buffer)) {
				result += "db '";
				while (is_string(*buffer) && !fl.eof()) {
					result += get_string(*buffer);
					fl.read((char*)buffer, 1);
				}
				result += "'\n";
				if (!fl.eof())
					fl.seekg(-1, fl.cur);
			}
			else result += "db " + std::to_string(*buffer) + "\n";

			break;

		};
		op_size = (1 << (mode + 4));
	}
	free(buffer);
	return result;
}